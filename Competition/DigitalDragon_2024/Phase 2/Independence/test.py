g, p = 5464549774190809852923763408523051958716400587576327799474715226373287205246183801056700913652415087121976663782311766735601091617825037804761387911068511, 9581257592556018473305786754018994054986440370491067910997313283399579058244765977967617476919486211692103485121526918608638896652486174462300514168144287

c1, c2 = 7135801671058767584309500409714690782210907857769654167278686110915938179468272566599508349773575527751255945760666566561800878978873221420946365250158855, 8558667795367217630200789973869614923107151017456755231025099578562328753501118840162746538211725967983893568561332219610117111942140345185312896115801764

from Crypto.Util.number import *

word = "independence"
x = bytes_to_long(word.encode())
#bruteforce x from word

# generate all substring of word

substrings = []
for i in range(1, len(word)+1):
    for j in range(len(word)-i+1):
        substrings.append(word[j:j+i])

for w in substrings:
    x = bytes_to_long(w.encode())
    h = pow(g, x, p)
    c2_pre = pow(pow(c1,2)*g,x,p)
    if c2 == c2_pre:
        print(w)
        break  
    else:
        print(f"{w} is not the correct word")
# c2_pre = pow(pow(c1,2)*g,x,p)

# print(c2 == c2_pre)